Approach: Using recurssion, traverse in binary tree, passing root and level.
at any time enocounter root == null, return the level 
and check if left level and right level has diffrence > 1 return -1 else return the max of left or right subtree.
class Solution {
    public boolean isBalanced(TreeNode root) {
       if(root == null){
           return true;
       }
        int height = isBalanceTree(root, 0);
        return (height != -1);
    }
    public int isBalanceTree(TreeNode root, int level) {
       if(root == null){
           return level;
       }
        int l = isBalanceTree(root.left, level+1);
        if(l == -1){
            return -1;
        }
        int r = isBalanceTree(root.right, level+1);
        if(l == -1){
            return -1;
        }
        if(Math.abs(l-r) > 1){
            return -1;
        }
        return Math.max(l, r);
    }
}
